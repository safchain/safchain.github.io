<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sylvain Afhcain&#39;s Techs Notes </title>
    <link>http://safchain.github.io/post/</link>
    <language>en-us</language>
    <author>Sylvain Afchain</author>
    <rights>(C) 2015</rights>
    <updated>2015-10-17 18:04:26 &#43;0200 CEST</updated>

    
      
        <item>
          <title>OpenContrail DevStack</title>
          <link>http://safchain.github.io/blog/2015/10/17/opencontrail-devstack/</link>
          <pubDate>Sat, 17 Oct 2015 18:04:26 CEST</pubDate>
          <author>Sylvain Afchain</author>
          <guid>http://safchain.github.io/blog/2015/10/17/opencontrail-devstack/</guid>
          <description>

&lt;p&gt;Some people asked me on IRC how to deploy an OpenContrail DevStack. So in this post I will provide two scripts in order to bootstrap such deployments, in a single node way or in a two nodes way.&lt;/p&gt;

&lt;h2 id=&#34;setup:0f62593a72a2c23f7ef3061c4673a32f&#34;&gt;Setup&lt;/h2&gt;

&lt;p&gt;Some requierements and recommendations about the sizing of the VM for your installation. The build process of Opencontrail is quite long so don&amp;rsquo;t hesitate to create a VM with more than one CPUi and at least 4Go of ram. I would suggest to have at least 2 network interfaces, OpenContrail can be installed with only one interface but if you plan to debug you will be more confident with an admin and user interface.&lt;/p&gt;

&lt;h2 id=&#34;all-in-one-node:0f62593a72a2c23f7ef3061c4673a32f&#34;&gt;All-In-One node&lt;/h2&gt;

&lt;p&gt;Below a script that just leverages the explaination that you can find &lt;a href=&#34;https://github.com/Juniper/contrail-installer&#34;&gt;here&lt;/a&gt;. Basically this script is creating a localrc file that the &lt;a href=&#34;https://github.com/Juniper/contrail-installer&#34;&gt;contrail-installer&lt;/a&gt; will use. Then it starts to build the whole solution. Finally it instanciates a devstack providing a correct local.conf. You will notice that this script does some weird stuffs like removing/upgrading some packages, this is here to fix dependencies issues.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#!/bin/bash

if [ -z &amp;quot;$2&amp;quot; ]
then
    echo &amp;quot;Usage: $0 &amp;lt;username@hostname&amp;gt; &amp;lt;interface&amp;gt;&amp;quot;
    exit -1
fi

HOST=$1
INTF=$2

# OpenContrail localrc file
LOCALRC=$(cat &amp;lt;&amp;lt;&#39;
USE_SCREEN=True
STACK_DIR=\$(cd \$(dirname \$0) &amp;amp;&amp;amp; pwd)
LOG_LEVEL=3
LOG_DIR=\$STACK_DIR/log/screens
LOGFILE=\$STACK_DIR/log/contrail.log
LOGDAYS=1

ADMIN_PASSWORD=contrail123

RABBIT_USER=stackrabbit
RABBIT_PASSWORD=\$ADMIN_PASSWORD

SERVICE_TIMEOUT=90
SERVICE_HOST=$IP

INSTALL_PROFILE=ALL

PHYSICAL_INTERFACE=$INTF

CASS_MAX_HEAP_SIZE=128M
CASS_HEAP_NEWSIZE=20M

CONTRAIL_DEFAULT_INSTALL=False

CONTRAIL_REPO_PROTO=https
NB_JOBS=4
&#39;)

# Devstack local.conf file
LOCALCONF=$(cat &amp;lt;&amp;lt;&#39;
[[local|localrc]]
RECLONE=yes

HOST_IP=$IP

PASSWORD=contrail123
ADMIN_PASSWORD=\$PASSWORD
MYSQL_PASSWORD=\$PASSWORD
RABBIT_PASSWORD=\$PASSWORD
SERVICE_PASSWORD=\$PASSWORD
SERVICE_TOKEN=token
MULTI_HOST=1

disable_service n-net tempest heat ec2
enable_service q-svc n-cpu key
Q_PLUGIN=opencontrail

NOVA_VIF_DRIVER=nova_contrail_vif.contrailvif.VRouterVIFDriver
LIBVIRT_FIREWALL_DRIVER=&amp;quot; &amp;quot;

KEYSTONE_USE_MOD_WSGI=False

LOGFILE=\$DEST/logs/stack.sh.log
LOGDAYS=1
SCREEN_LOGDIR=\$DEST/logs/screen
&#39;)

# OpenContrail Install
ssh $1 &amp;lt;&amp;lt;EOF
    export IP=\$(ip addr | grep -E &#39;inet.*$INTF&#39; | awk &#39;{print \$2}&#39; | cut -d &#39;/&#39; -f 1)
    export INTF=$INTF

    sudo apt-get install -y git
    ls contrail-installer || git clone \
        http://github.com/juniper/contrail-installer.git
    echo -e &amp;quot;$LOCALRC&amp;quot; &amp;gt; contrail-installer/localrc
    cd contrail-installer
    ./contrail.sh build
    ./contrail.sh build
    ./contrail.sh install
    ./contrail.sh configure
    sudo pip install &amp;quot;greenlet&amp;gt;=0.4.7&amp;quot; --upgrade
    ./contrail.sh start

    sleep 30
    cd ..

    ls devstack || git clone http://github.com/openstack-dev/devstack.git
    echo -e &amp;quot;$LOCALCONF&amp;quot; &amp;gt; devstack/local.conf
    sudo apt-get remove --purge -y python-pastedeploy
    cd devstack
    ./unstack.sh
    cp cp ../contrail-installer/devstack/lib/neutron_thirdparty/opencontrail \
        lib/neutron_thirdparty/opencontrail
    cp ../contrail-installer/devstack/lib/neutron_plugins/opencontrail \
        lib/neutron_plugins/opencontrail
    ./stack.sh
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;compute-node:0f62593a72a2c23f7ef3061c4673a32f&#34;&gt;Compute node&lt;/h2&gt;

&lt;p&gt;Below almost the same script, but this one will start what is needed for a compute node.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#!/bin/bash

if [ -z &amp;quot;$3&amp;quot; ]
then
    echo &amp;quot;Usage: $0 &amp;lt;username@hostname&amp;gt; &amp;lt;interface&amp;gt; &amp;lt;controller ip&amp;gt;&amp;quot;
    exit -1
fi

HOST=$1
INTF=$2
CTL=$3

# OpenContrail localrc file
LOCALRC=$(cat &amp;lt;&amp;lt;&amp;lt;&#39;
USE_SCREEN=True
STACK_DIR=\$(cd \$(dirname \$0) &amp;amp;&amp;amp; pwd)
LOG_LEVEL=3
LOG_DIR=\$STACK_DIR/log/screens
LOGFILE=\$STACK_DIR/log/contrail.log
LOGDAYS=1

ADMIN_PASSWORD=contrail123

RABBIT_USER=stackrabbit
RABBIT_PASSWORD=\$ADMIN_PASSWORD

SERVICE_TIMEOUT=90
SERVICE_HOST=$CTL
COMPUTE_HOST_IP=$IP

INSTALL_PROFILE=COMPUTE

PHYSICAL_INTERFACE=$INTF

CASS_MAX_HEAP_SIZE=128M
CASS_HEAP_NEWSIZE=20M

CONTRAIL_DEFAULT_INSTALL=False

CONTRAIL_REPO_PROTO=https
NB_JOBS=4
&#39;)

# Devstack local.conf file
LOCALCONF=$(cat &amp;lt;&amp;lt;&amp;lt;&#39;
[[local|localrc]]
RECLONE=yes

HOST_IP=$IP

PASSWORD=contrail123
ADMIN_PASSWORD=\$PASSWORD
MYSQL_PASSWORD=\$PASSWORD
RABBIT_PASSWORD=\$PASSWORD
SERVICE_PASSWORD=\$PASSWORD
SERVICE_TOKEN=token
MULTI_HOST=1

NOVA_VIF_DRIVER=nova_contrail_vif.contrailvif.VRouterVIFDriver
LIBVIRT_FIREWALL_DRIVER=&amp;quot; &amp;quot;

ENABLED_SERVICES=n-cpu,neutron

SERVICE_HOST=$CTL
MYSQL_HOST=\$SERVICE_HOST
RABBIT_HOST=\$SERVICE_HOST
Q_HOST=\$SERVICE_HOST
GLANCE_HOSTPORT=\$SERVICE_HOST:9292

VNCSERVER_PROXYCLIENT_ADDRESS=\$HOST_IP
VNCSERVER_LISTEN=0.0.0.0

LOGFILE=\$DEST/logs/stack.sh.log
LOGDAYS=1
SCREEN_LOGDIR=\$DEST/logs/screen
&#39;)

# OpenContrail Install
ssh $1 &amp;lt;&amp;lt;EOF
    export IP=\$(ip addr | grep -E &#39;inet.*$INTF&#39; | awk &#39;{print \$2}&#39; | cut -d &#39;/&#39; -f 1)
    export INTF=$INTF
    export CTL=$CTL

    sudo apt-get install -y git
    ls contrail-installer || git clone \
        http://github.com/juniper/contrail-installer.git
    echo -e &amp;quot;$LOCALRC&amp;quot; &amp;gt; contrail-installer/localrc
    cd contrail-installer
    ./contrail.sh build
    ./contrail.sh build
    ./contrail.sh install
    ./contrail.sh configure
    sudo pip install &amp;quot;greenlet&amp;gt;=0.4.7&amp;quot; --upgrade
    ./contrail.sh start

    sleep 30
    cd ..

    ls devstack || git clone http://github.com/openstack-dev/devstack.git
    echo -e &amp;quot;$LOCALCONF&amp;quot; &amp;gt; devstack/local.conf
    sudo apt-get remove --purge -y python-pastedeploy
    cd devstack
    ./unstack.sh
    cp cp ../contrail-installer/devstack/lib/neutron_thirdparty/opencontrail \
        lib/neutron_thirdparty/opencontrail
    cp ../contrail-installer/devstack/lib/neutron_plugins/opencontrail \
        lib/neutron_plugins/opencontrail
    ./stack.sh
EOF
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Opencontrail on the Controller side</title>
          <link>http://safchain.github.io/blog/2015/10/05/opencontrail-on-the-controller-side/</link>
          <pubDate>Mon, 05 Oct 2015 22:40:48 CEST</pubDate>
          <author>Sylvain Afchain</author>
          <guid>http://safchain.github.io/blog/2015/10/05/opencontrail-on-the-controller-side/</guid>
          <description>

&lt;p&gt;&lt;em&gt;Original post I wrote &lt;a href=&#34;http://blogs.rdoproject.org/7793/opencontrail-on-the-controller-side&#34;&gt;here&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;In my previous &lt;a href=&#34;http://safchain.github.io/post/a_journey_of_a_packet_within_opencontrail/&#34;&gt;post&lt;/a&gt; I explained how packets are forwarded from point to point within OpenContrail. We saw the tools available to check what are the routes involved in the forwarding. Last time we focused on the agent side but now we are going to understand on another key component: the controller.&lt;/p&gt;

&lt;p&gt;The controller acts as a Route Reflector, announcing routes according to what has been done on the Config/API side and the peering nodes. As we saw in the dataplane post, the controller is using BGP or XMPP in order to exchange routes. XMPP is used between the controllers and the vRouters, BGP is used between the controllers and the gateway routers. One more thing about XMPP, even if it is used for route announcements this is not its only goal. It is used for some other purposes like Service-Chaining, Virtual-Machine related informations, etc.&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://safchain.github.io/images/opencontrail_on_the_controller_side/image02.png&#34; alt=&#34;&#34; class=&#34;pure-img&#34; &gt;&lt;/center&gt;
&lt;/p&gt;

&lt;p&gt;Taking the same example as previously I will explain how the routes are announced between the controllers and the vRouters and between the controllers and the gateway routers. I also will explain the capability of OpenContrail to extend private network outside the cloud leveraging the L3VPNs.&lt;/p&gt;

&lt;h2 id=&#34;ok-but-what-happens-when-i-boot-vm:739aa33fa6e01f8f1998753dfb50867b&#34;&gt;Ok but, what happens when I boot VM&lt;/h2&gt;

&lt;p&gt;Before continuing to explain the routing aspect within OpenContrail, I think it can be useful to explain what happens when we boot a VM and for what kind of purpose OpenContrail is using XMPP between the controllers and the vRouter.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;When we boot a VM, for example with Nova, the OpenContrail Nova VIF driver[10] asks the vRouter agent for creating a vif interface, thanks to its &lt;a href=&#34;https://github.com/Juniper/contrail-controller/tree/master/src/vnsw/contrail-vrouter-api&#34;&gt;API&lt;/a&gt;. The request is made with all the informations needed to create the interface (name, mac, etc) along with the VM UUID.&lt;/li&gt;
&lt;li&gt;Thanks to this VM UUID, the vRouter agent is going to subscribe to controllers for thatthis particular virtual machine.&lt;/li&gt;
&lt;li&gt;As a result of this subscription, the vRouter agent will receive all the informations (part of the &lt;a href=&#34;http://www.if-map.org&#34;&gt;graph&lt;/a&gt;) related to this Virtual-Machine (Security-Group, Instance-IP, Routing-Instance, etc.).&lt;/li&gt;
&lt;li&gt;At this point the vRouter agent will be able to announce routes to the controllers about the reachability of our VM.&lt;/li&gt;
&lt;li&gt;The vRouter agent will subscribe with the controller to the Routing-Instance on which our VM is connected, so that it will receive all the routing informations related to this Routing-Instance along with the information on the Virtual-Network.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As usual OpenContrail gives you all the informations about the XMPP exchanges, thanks to the introspect interfaces. Below extracts (formatted) from the introspect interfaces when booting a VM.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;For the agent side :&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;http://&lt;agent ip&gt;:8085/Snh_SandeshTraceRequest?x=XmppMessageTrace&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;2015-07-25 15:48:41.506 XmppTxStream: Sent xmpp message to: 10.43.91.10 Port 5269 Size: 238 Packet:
&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;iq type=&amp;quot;set&amp;quot; from=&amp;quot;os2&amp;quot; to=&amp;quot;network-control@contrailsystems.com/config&amp;quot;&amp;gt;
   &amp;lt;pubsub xmlns=&amp;quot;http://jabber.org/protocol/pubsub&amp;quot;&amp;gt;
      &amp;lt;subscribe node=&amp;quot;virtual-machine:213d8cec-c37d-44f0-809e-51493c9dff84&amp;quot; /&amp;gt;
   &amp;lt;/pubsub&amp;gt;
&amp;lt;/iq&amp;gt;

2015-07-24 15:48:41.510 XmppRxStream: Received xmpp message from: 10.43.91.10 Port 5269 Size: 5229 Packet:
&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;iq type=&amp;quot;set&amp;quot; from=&amp;quot;network-control@contrailsystems.com&amp;quot; to=&amp;quot;default-global-system-config:os2/config&amp;quot;&amp;gt;
   &amp;lt;config&amp;gt;
      &amp;lt;update&amp;gt;
         &amp;lt;node type=&amp;quot;virtual-machine&amp;quot;&amp;gt;
            &amp;lt;name&amp;gt;213d8cec-c37d-44f0-809e-51493c9dff84&amp;lt;/name&amp;gt;
            &amp;lt;id-perms&amp;gt;...&amp;lt;/id-perms&amp;gt;
            &amp;lt;display-name&amp;gt;213d8cec-c37d-44f0-809e-51493c9dff84&amp;lt;/display-name&amp;gt;
         &amp;lt;/node&amp;gt;
         &amp;lt;link&amp;gt;
            &amp;lt;node type=&amp;quot;virtual-router&amp;quot;&amp;gt;
               &amp;lt;name&amp;gt;default-global-system-config:os2&amp;lt;/name&amp;gt;
            &amp;lt;/node&amp;gt;
            &amp;lt;node type=&amp;quot;virtual-machine&amp;quot;&amp;gt;
               &amp;lt;name&amp;gt;213d8cec-c37d-44f0-809e-51493c9dff84&amp;lt;/name&amp;gt;
            &amp;lt;/node&amp;gt;
            &amp;lt;metadata type=&amp;quot;virtual-router-virtual-machine&amp;quot; /&amp;gt;
         &amp;lt;/link&amp;gt;
         &amp;lt;node type=&amp;quot;virtual-machine-interface&amp;quot;&amp;gt;
          &amp;lt;name&amp;gt;default-domain:demo:55b49e32-b858-48e7-8746-6e09005ecc79&amp;lt;/name&amp;gt;
            &amp;lt;virtual-machine-interface-mac-addresses&amp;gt;
               &amp;lt;mac-address&amp;gt;02:55:b4:9e:32:b8&amp;lt;/mac-address&amp;gt;
            &amp;lt;/virtual-machine-interface-mac-addresses&amp;gt;
            &amp;lt;virtual-machine-interface-device-owner&amp;gt;compute:nova&amp;lt;/virtual-machine-interface-device-owner&amp;gt;
      ...
         &amp;lt;/node&amp;gt;
         ...
         &amp;lt;node type=&amp;quot;instance-ip&amp;quot;&amp;gt;
            &amp;lt;name&amp;gt;abc3bd27-d5df-495a-9fb8-dab474470258&amp;lt;/name&amp;gt;
            &amp;lt;instance-ip-address&amp;gt;10.0.0.3&amp;lt;/instance-ip-address&amp;gt;
            &amp;lt;instance-ip-family&amp;gt;v4&amp;lt;/instance-ip-family&amp;gt;
      ...
         &amp;lt;/node&amp;gt;
         &amp;lt;link&amp;gt;...&amp;lt;/link&amp;gt;
         &amp;lt;node type=&amp;quot;virtual-machine-interface-routing-instance&amp;quot;&amp;gt;
            &amp;lt;name&amp;gt;attr(default-domain:demo:55b49e32-b858-48e7-8746-6e09005ecc79,default-domain:demo:private:private)&amp;lt;/name&amp;gt;
            &amp;lt;value&amp;gt;...&amp;lt;/value&amp;gt;
         &amp;lt;/node&amp;gt;
         &amp;lt;link&amp;gt;...&amp;lt;/link&amp;gt;
      &amp;lt;/update&amp;gt;
   &amp;lt;/config&amp;gt;
&amp;lt;/iq&amp;gt;

...

2015-07-24 15:48:42.766 XmppTxStream: Sent xmpp message to: 10.43.91.10 Port 5269 Size: 871 Packet:
&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;iq type=&amp;quot;set&amp;quot; from=&amp;quot;os2&amp;quot; to=&amp;quot;network-control@contrailsystems.com/bgp-peer&amp;quot; id=&amp;quot;pubsub3&amp;quot;&amp;gt;
   &amp;lt;pubsub xmlns=&amp;quot;http://jabber.org/protocol/pubsub&amp;quot;&amp;gt;
      &amp;lt;publish node=&amp;quot;1/1/default-domain:demo:private:private/10.0.0.4&amp;quot;&amp;gt;
         &amp;lt;item&amp;gt;
            &amp;lt;entry&amp;gt;
               &amp;lt;nlri&amp;gt;
                  &amp;lt;af&amp;gt;1&amp;lt;/af&amp;gt;
                  &amp;lt;safi&amp;gt;1&amp;lt;/safi&amp;gt;
                  &amp;lt;address&amp;gt;10.0.0.4/32&amp;lt;/address&amp;gt;
               &amp;lt;/nlri&amp;gt;
               &amp;lt;next-hops&amp;gt;
                  &amp;lt;next-hop&amp;gt;
                     &amp;lt;af&amp;gt;1&amp;lt;/af&amp;gt;
                     &amp;lt;address&amp;gt;10.43.91.10&amp;lt;/address&amp;gt;
                     &amp;lt;label&amp;gt;19&amp;lt;/label&amp;gt;
                     &amp;lt;tunnel-encapsulation-list&amp;gt;
                        &amp;lt;tunnel-encapsulation&amp;gt;gre&amp;lt;/tunnel-encapsulation&amp;gt;
                        &amp;lt;tunnel-encapsulation&amp;gt;udp&amp;lt;/tunnel-encapsulation&amp;gt;
                     &amp;lt;/tunnel-encapsulation-list&amp;gt;
                  &amp;lt;/next-hop&amp;gt;
               &amp;lt;/next-hops&amp;gt;
               ...
            &amp;lt;/entry&amp;gt;
         &amp;lt;/item&amp;gt;
      &amp;lt;/publish&amp;gt;
   &amp;lt;/pubsub&amp;gt;
&amp;lt;/iq&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;For the controller side :&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;http://&lt;controller ip&gt;:8083/Snh_SandeshTraceRequest?x=BgpTraceBuf&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;2015-07-25 15:48:42.804 XmppPeerInstanceTrace: XMPP Peer os2:10.43.91.10 in
instance default-domain:demo:private:private : Inet route 10.0.0.4/32
with next-hop 10.43.91.10 and label 19 is enqueued
for add/change

2015-07-25 15:48:42.804 XmppPeerRouteTrace: XMPP Peer os2:10.43.91.10 Insert
new BGP path 10.0.0.4/32 in table default-domain:demo:private:private.inet.0

2015-07-25 15:48:42.804 XmppPeerInstanceTrace: XMPP Peer os2:10.43.91.10 in
instance default-domain:demo:private:private : Evpn route
02:55:b4:9e:32:b8,10.0.0.4/32 with next-hop 10.43.91.10 and
label 20 is enqueued for add/change

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;from-high-level-api-resources-to-network-resources:739aa33fa6e01f8f1998753dfb50867b&#34;&gt;From High level API resources to Network resources&lt;/h2&gt;

&lt;p&gt;To explain how the routing works within OpenContrail let’s take the same example from the previous post, two VMs on two different networks.&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://safchain.github.io/images/opencontrail_on_the_controller_side/image01.png&#34; alt=&#34;&#34; class=&#34;pure-img&#34; &gt;&lt;/center&gt;
&lt;/p&gt;

&lt;p&gt;In order to interconnect the two networks, we add a virtual router between them. The interesting thing is that, in OpenContrail this router will not be really created. This is just a logical view, even if we can find it requesting the API.&lt;/p&gt;

&lt;p&gt;Actually, the virtual router, called Logical-Router in the Opencontrail terminology, will be like translated to some other network resources. There is a special component which handles such translations - &lt;em&gt;&amp;ldquo;Schema-Transformer&amp;rdquo;&lt;/em&gt;. The Schema-Transformer converts high level resources to network resources.&lt;/p&gt;

&lt;p&gt;When a virtual network is created at the API side, the Schema-Transformer creates and associates a Routing-Instance to the newly created network. It dynamically allocates a unique  Route-Target (Which acts as a VNI) and associates it to the Routing-Instance.&lt;/p&gt;

&lt;p&gt;At the API side we can check the result of the resources created by the Schema-Transformer, thus what is the Routing-Instance for a specific network, for instance for our private network.&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://safchain.github.io/images/opencontrail_on_the_controller_side/image03.png&#34; alt=&#34;&#34; class=&#34;pure-img&#34; &gt;&lt;/center&gt;
&lt;/p&gt;

&lt;p&gt;and the Route-Target associated…&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://safchain.github.io/images/opencontrail_on_the_controller_side/image01.png&#34; alt=&#34;&#34; class=&#34;pure-img&#34; &gt;&lt;/center&gt;
&lt;/p&gt;

&lt;p&gt;To summarize, we have two virtual networks, each with a routing-instance with a specific Route-Target :&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Virtual network&lt;/th&gt;
&lt;th&gt;Route-Target&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;private&lt;/td&gt;
&lt;td&gt;target:64512:8000001&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;service&lt;/td&gt;
&lt;td&gt;target:64512:8000002&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;There is currently three way of defining a &lt;a href=&#34;http://tools.ietf.org/html/rfc4364&#34;&gt;Route-Target&lt;/a&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;2 bytes of ASN, 4 bytes of value&lt;/li&gt;
&lt;li&gt;4 bytes of ASN, 2 bytes of value&lt;/li&gt;
&lt;li&gt;4 bytes of IP, 2 bytes of value&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A route target within OpenContrail is composed of an  ASN and a number higher than 8000000 allocated by the Schema-Transformer and which is of course unique per routing-instance.&lt;/p&gt;

&lt;p&gt;Back to our Logical Router, notified by the API, the Schema-Transformer creates a Route-Target and associates it to the newly created Logical Router.&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://safchain.github.io/images/opencontrail_on_the_controller_side/image04.png&#34; alt=&#34;&#34; class=&#34;pure-img&#34; &gt;&lt;/center&gt;
&lt;/p&gt;

&lt;p&gt;This Route-Target will be associated to the Routing-Instance of each virtual network on which the Logical Router is linked to. Thanks to this Route-Target, shared across the Routing-instances the routes of both network will be leaked at the controller level.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Virtual network&lt;/th&gt;
&lt;th&gt;Route-Target&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;private&lt;/td&gt;
&lt;td&gt;target:64512:8000001&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;target:64512:8000003 (logical-router)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;service&lt;/td&gt;
&lt;td&gt;target:64512:8000002&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;target:64512:8000003 (logical-router)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;On the API side it will give us two Route-Targets for both Routing-Instances, one for the Virtual Network/Routing-Instance, another one coming from the Logical Router :&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://safchain.github.io/images/opencontrail_on_the_controller_side/image07.png&#34; alt=&#34;&#34; class=&#34;pure-img&#34; &gt;&lt;/center&gt;
&lt;/p&gt;

&lt;p&gt;As seen in the previous post Routing-Instance are VRFs at vRouter Agent side. Thus a logical router is finally a way to express import/export rules of routes between VRFs, so a way of leaking routes between them.&lt;/p&gt;

&lt;h2 id=&#34;controller-time:739aa33fa6e01f8f1998753dfb50867b&#34;&gt;Controller time !&lt;/h2&gt;

&lt;p&gt;Now that the Schema-Transformer translated the high level resources, we should be able to find them in the controller thanks to the dedicated introspect interface.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;http://&lt;controller ip&gt;:8083/Snh_ShowRoutingInstanceReq&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Selecting the private routing instance we get&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The Route-Target imported/exported&lt;/li&gt;
&lt;li&gt;The route tables&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://safchain.github.io/images/opencontrail_on_the_controller_side/image11.png&#34; alt=&#34;&#34; class=&#34;pure-img&#34; &gt;&lt;/center&gt;
&lt;/p&gt;

&lt;p&gt;We will focus on the route table inet.0 which is the route table for the unicast IPV4 routes.&lt;/p&gt;

&lt;p&gt;Clicking on it, we get all the routes details for this route table, ex : from where a route is learned, from os2 and os3, my two compute nodes in this setup as shown below.&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://safchain.github.io/images/opencontrail_on_the_controller_side/image10.png&#34; alt=&#34;&#34; class=&#34;pure-img&#34; &gt;&lt;/center&gt;
&lt;/p&gt;

&lt;p&gt;I removed some informations from this capture since this is really a wide page, but scrolling to the right we will see that the Next-Hop is indicated as well.&lt;/p&gt;

&lt;p&gt;As explain before we can check what are the routes received at the agent level, since it is subscribing to the Routing-Instances. Below the route leaked from the service network :&lt;/p&gt;

&lt;p&gt;http://&lt;agent ip&gt;:8085/Snh_SandeshTraceRequest?x=XmppMessageTrace&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;2015-07-25 14:29:02.088 XmppRxStream: Received xmpp message from: 10.43.91.10 Port 5269 Size: 1021 Packet:
&amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt;
&amp;lt;message from=&amp;quot;network-control@contrailsystems.com&amp;quot; to=&amp;quot;os2/bgp-peer&amp;quot;&amp;gt;
&amp;lt;event xmlns=&amp;quot;http://jabber.org/protocol/pubsub&amp;quot;&amp;gt;
&amp;lt;items node=&amp;quot;1/1/default-domain:demo:private:private&amp;quot;&amp;gt;
&amp;lt;item id=&amp;quot;192.168.0.3/32&amp;quot;&amp;gt;
&amp;lt;entry&amp;gt;
    &amp;lt;nlri&amp;gt;...&amp;lt;/nlri&amp;gt;
    &amp;lt;next-hops&amp;gt;
        &amp;lt;next-hop&amp;gt;
            &amp;lt;af&amp;gt;1&amp;lt;/af&amp;gt;
            &amp;lt;address&amp;gt;10.43.91.12&amp;lt;/address&amp;gt;
            &amp;lt;label&amp;gt;16&amp;lt;/label&amp;gt;
            &amp;lt;tunnel-encapsulation-list&amp;gt;...&amp;lt;/tunnel-encapsulation-list&amp;gt;
        &amp;lt;/next-hop&amp;gt;
    &amp;lt;/next-hops&amp;gt;
...

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;routing-without-virtual-router:739aa33fa6e01f8f1998753dfb50867b&#34;&gt;Routing without virtual router&lt;/h2&gt;

&lt;p&gt;We just saw that a virtual router is just a logical view. We may want to install routing between our two networks without creating a logical router. For that we have to add the same route target to our both network, let’s say target:64512:444.&lt;/p&gt;

&lt;p&gt;Two ways of doing that, the OpenContrail WebUI editing both networks, adding the Route-Target :&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://safchain.github.io/images/opencontrail_on_the_controller_side/image06.png&#34; alt=&#34;&#34; class=&#34;pure-img&#34; &gt;&lt;/center&gt;
&lt;/p&gt;

&lt;p&gt;or thanks to a command line tool[3], thus via the OpenContrail API :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ python add_route_target.py --routing_instance_name \
default-domain:demo:private:private --route_target_number 444 \
--router_asn 64512 --api_server_ip localhost --api_server_port 8082 \
--admin_user admin --admin_password contrail123 --admin_tenant_name admin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Currently there is no way to manage Route-Targets with the Neutron API, but there is an on going work through the &lt;a href=&#34;https://git.openstack.org/cgit/openstack/networking-bgpvpn&#34;&gt;BGPVPN service-plugin/extension&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;what-about-external-networks:739aa33fa6e01f8f1998753dfb50867b&#34;&gt;What about external networks ?&lt;/h2&gt;

&lt;p&gt;For the external networks, this is almost the same thing. We just need to add a Route-Target to the Routing-Instance of the “external network” on both side, the gateway router and OpenContrail. This Route-Target will take the form of an &lt;a href=&#34;http://tools.ietf.org/html/rfc4360&#34;&gt;extended BGP community&lt;/a&gt;. The gateway routers peering with the controllers using the BGP protocol will be able to import/export routes from/to our “external network”, especially the default route for the OpenContrail side and the floating-ips for the gateway router side.&lt;/p&gt;

&lt;p&gt;Assuming we use the Route-Target 64512:555, and we provisioned the gateway router via the OpenContrail WebUI, we can add the Route Target on the routing-instance on the router side. I’m not going to explain here the details on how to setup a gateway router, there is a pretty good explanation &lt;a href=&#34;http://www.opencontrail.org/how-to-setup-opencontrail-gateway-juniper-mx-cisco-asr-and-software-gw&#34;&gt;here&lt;/a&gt;. Below just an extract of a Juniper router configuration.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# show routing-instances
routing-instances {
    public {
        instance-type vrf;
        interface lt-0/0/0.1;
        vrf-target target:64512:555;
            routing-options {
                    static {
                        route 0.0.0.0/0 next-hop lt-0/0/0.1;
                    }
            }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we have a gateway router with a default route for the public routing-instance, we should be able to find it on the control side.&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://safchain.github.io/images/opencontrail_on_the_controller_side/image05.png&#34; alt=&#34;&#34; class=&#34;pure-img&#34; &gt;&lt;/center&gt;
&lt;/p&gt;

&lt;p&gt;Associating a floating-ip to a VM, we can check on the router side that the route for the floating-ip is correctly announced.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;gt; show route table public.inet.0

public.inet.0: 24 destinations, 24 routes (24 active, 0 holddown, 0 hidden)
+ = Active Route, - = Last Active, * = Both

…

172.16.0.3/32      *[BGP/170] 00:12:24, localpref 200, from 10.43.91.10
                      AS path: ?
                    &amp;gt; via gre.32769, Push 16

...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;opencontrail-and-exabgp-for-fun-troubleshooting:739aa33fa6e01f8f1998753dfb50867b&#34;&gt;OpenContrail and ExaBGP for fun… troubleshooting&lt;/h2&gt;

&lt;p&gt;Since the OpenContrail controller is a BGP Speaker we can use the well known BGP Swiss army knife : ExaBGP. Adding ExaBGP as BGP peer to OpenContrail we should be able to dump all the announcements.
Below is an &lt;a href=&#34;https://github.com/safchain/opencontrail_tools/tree/master/exabgp_dump&#34;&gt;ExaBGP config file and a python script&lt;/a&gt; that aim to dump all the BGP traffic in human readable way.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;group oc {
    router-id 10.43.91.13;
    local-as 64512;
    local-address 10.43.91.13;

    process dump {
        run dump.py;
        encoder json;
        receive {
            parsed;
            update;
        }
    }

    neighbor 10.43.91.10 {
            peer-as 64512;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/python

from datetime import datetime
import json
import os
import pprint
import struct
from sys import stdin, stdout, stderr
import time


def ext_community_to_raw(value):
    raw = &#39;&#39;
    while value:
        b = struct.pack(&amp;quot;B&amp;quot;, value &amp;amp; 0xff)
        raw = b + raw
        value &amp;gt;&amp;gt;= 8

    if len(raw) &amp;lt; 8:
        raw = &#39;\0&#39; + raw

    return raw


while True:
    try:
        line = stdin.readline().strip()
        msg = json.loads(line)

        try:
            attribute = msg[&#39;neighbor&#39;][&#39;message&#39;][&#39;update&#39;][&#39;attribute&#39;]
            ext_communities = attribute[&#39;extended-community&#39;]

            for idx in range(len(ext_communities)):
                ext_community = ext_communities[idx]
                raw = ext_community_to_raw(ext_community)
                if ord(raw[0]) == 0x00 and ord(raw[1]) == 0x02:
                    asn, number = struct.unpack(&#39;!HL&#39;, raw[2:8])
                    ext_communities[idx] = &amp;quot;target:%d:%d&amp;quot; % (asn, number)
        except:
            pass

        timestamp = datetime.fromtimestamp(msg[&#39;time&#39;])
        stderr.write(&amp;quot;# %s\n&amp;quot; % timestamp)
        stderr.write(pprint.pformat(msg, width=80) + &amp;quot;\n\n&amp;quot;)
    except IOError:
        pass
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ sudo exabgp dump.ini

...
# 2015-08-05 21:26:51
{
  &amp;quot;counter&amp;quot;: 2,
  &amp;quot;exabgp&amp;quot;: &amp;quot;3.4.8&amp;quot;,
  &amp;quot;host&amp;quot;: &amp;quot;exa&amp;quot;,
  &amp;quot;neighbor&amp;quot;: {
    &amp;quot;address&amp;quot;: {
      &amp;quot;local&amp;quot;: &amp;quot;10.43.91.13&amp;quot;,
      &amp;quot;peer&amp;quot;: &amp;quot;10.43.91.10&amp;quot;
    },
    &amp;quot;asn&amp;quot;: {
      &amp;quot;local&amp;quot;: &amp;quot;64512&amp;quot;,
      &amp;quot;peer&amp;quot;: &amp;quot;64512&amp;quot;
    },
    &amp;quot;ip&amp;quot;: &amp;quot;10.43.91.10&amp;quot;,
    &amp;quot;message&amp;quot;: {
      &amp;quot;update&amp;quot;: {
        &amp;quot;announce&amp;quot;: {
          &amp;quot;ipv4 mpls-vpn&amp;quot;: {
            &amp;quot;10.43.91.10&amp;quot;: {
              &amp;quot;172.16.0.3/32&amp;quot;: {
                &amp;quot;label&amp;quot;: [
                  16
                ],
                &amp;quot;route-distinguisher&amp;quot;: &amp;quot;10.43.91.10:2&amp;quot;
              }
            }
          }
        },
        &amp;quot;attribute&amp;quot;: {
          &amp;quot;extended-community&amp;quot;: [
            &amp;quot;target:64512:555&amp;quot;,
            &amp;quot;target:64512:8000004&amp;quot;,
            219550481834311682,
            219550481834311693,
            219550481834348681,
            432346663739195393,
            9224775013699817985,
            9255455786153279494
          ],
          &amp;quot;local-preference&amp;quot;: 200,
          &amp;quot;origin&amp;quot;: &amp;quot;incomplete&amp;quot;
        }
      }
    }
  }
}
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So we see the floating-ip and the Route-Target used for the public network (target:64512:555)&lt;/p&gt;

&lt;h2 id=&#34;conclusion:739aa33fa6e01f8f1998753dfb50867b&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;As explained in the previous post, OpenContrail relies on well known protocols and uses them for internally for the control-plane/data-plane. The ability of OpenContrail to use the same protocols internally and externally allows it to be fully integrated in Data-Centers and simplify its integration with access networks.&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>A journey of a packet within OpenContrail</title>
          <link>http://safchain.github.io/blog/2015/10/02/a-journey-of-a-packet-within-opencontrail/</link>
          <pubDate>Fri, 02 Oct 2015 08:51:26 CEST</pubDate>
          <author>Sylvain Afchain</author>
          <guid>http://safchain.github.io/blog/2015/10/02/a-journey-of-a-packet-within-opencontrail/</guid>
          <description>

&lt;p&gt;&lt;em&gt;Original post I wrote &lt;a href=&#34;http://blogs.rdoproject.org/7640/a-journey-of-a-packet-within-opencontrail&#34;&gt;here&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;In this post we will see how a packet generated by a VM is able to reach another VM or an external resource, what are the key concepts/components in the context of Neutron using the OpenContrail plugin. We will focus on OpenContrail, how it implements the overlay and the tools that it provides to check/troubleshoot how the packet are forwarded. Before getting started, I’ll give a little overview of the key concepts of OpenContrail.&lt;/p&gt;

&lt;h2 id=&#34;virtual-networks-overlay-with-opencontrail:179d514ae3c3b78a4f7f2f1b4b74e1e6&#34;&gt;Virtual networks, Overlay with OpenContrail&lt;/h2&gt;

&lt;p&gt;For the overlay, OpenContrail uses MPLS L3VPNs and MPLS EVPNs in order to address both l3 overlay and l2 overlay. There are a lot of components within OpenContrail, however we will focus on two key components – controller and the vRouter.&lt;/p&gt;

&lt;p&gt;For the control plane each controller acts as a BGP Route Reflector using the BGP and the XMPP protocols. BGP is used between the controllers and the physical routers. XMPP is used between the controllers and the vRouters. The XMPP protocol transports BGP route announcements but also some other informations for non routing needs.&lt;/p&gt;

&lt;p&gt;For the data plane, OpenContrail supports GRE/VXLAN/UDP for the tunneling. OpenContrail requires the following features to be supported by the gateway router :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;L3VPN

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://tools.ietf.org/html/rfc4364&#34;&gt;http://tools.ietf.org/html/rfc4364&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;MP-BGP

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://tools.ietf.org/html/rfc4760&#34;&gt;http://tools.ietf.org/html/rfc4760&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Dynamic Tunneling&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://safchain.github.io/images/a_journey_of_a_packet_within_opencontrail/image01.png&#34; alt=&#34;&#34; class=&#34;pure-img&#34; &gt;&lt;/center&gt;
&lt;/p&gt;

&lt;p&gt;In this post we will focus on the data plane area.&lt;/p&gt;

&lt;h2 id=&#34;the-packet-s-journey:179d514ae3c3b78a4f7f2f1b4b74e1e6&#34;&gt;The packet’s journey&lt;/h2&gt;

&lt;p&gt;In order to show what is the journey of a packet, let’s play with the following topology, where we have two VMs on two different networks connected thanks to a router.&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://safchain.github.io/images/a_journey_of_a_packet_within_opencontrail/image02.png&#34; alt=&#34;&#34; class=&#34;pure-img&#34; &gt;&lt;/center&gt;
&lt;/p&gt;

&lt;p&gt;Assuming we have allowed the ICMP packets by setting the security groups accordingly we can start a ping from &lt;em&gt;vm1&lt;/em&gt; toward &lt;em&gt;vm2&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;There are a lot of introspection tools within OpenContrail which can be used to get a clear status on how the packets are forwarded.&lt;/p&gt;

&lt;p&gt;Initiating a ping between &lt;em&gt;vm1&lt;/em&gt; and &lt;em&gt;vm2&lt;/em&gt;, we can check step by step where the packets go.&lt;/p&gt;

&lt;p&gt;Since the VMs are not on the same network, they will both use their default gateway. The local vRouter answers to the ARP request of the default gateway IP with its own MAC.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vm1$ ip route
default via 10.0.0.1 dev eth0
10.0.0.0/24 dev eth0  src 10.0.0.3

vm1$ cat /proc/net/arp
IP address       HW type     Flags       HW address            Mask     Device
10.0.0.1         0x1         0x2         00:00:5e:00:01:00     *        eth0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we have seen that the packets will be forwarded to the local vRouter, we are going to check how the vRouter will forward them.&lt;/p&gt;

&lt;p&gt;So let’s start by checking at the data plane layer by browsing the vRouter agent introspect Web interface running on the compute nodes hosting our VMs at &lt;em&gt;http://&lt;vrouter agent ip&gt;:8085/agent.xml&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;VrfListReq, http://&lt;vrouter agent ip&gt;:8085/Snh_VrfListReqWhich gives you the networks and the VRFs related. For a given VRF – let’s say the Unicast VRF (ucindex) – we can see all the routes.&lt;/li&gt;
&lt;li&gt;ItfReq, http://&lt;vrouter agent ip&gt;:8085/Snh_ItfReqWhich gives you all the interfaces handled by the vRouter.&lt;/li&gt;
&lt;li&gt;MplsReq, http://&lt;vrouter agent ip&gt;:8085/Snh_MplsReqWhich gives all the association MPLS Label/NextHop for the given vRouter.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These interfaces are just XML document rendered thanks to a XSL stylesheet, so can be easily processed by some monitoring scripts for example.&lt;/p&gt;

&lt;p&gt;We can start by the interfaces (&lt;em&gt;ItfReq&lt;/em&gt;) introspect page to find the TAP interface corresponding to &lt;em&gt;vm1&lt;/em&gt;. The name of the TAP contains a part of the neutron port ID.&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://safchain.github.io/images/a_journey_of_a_packet_within_opencontrail/image00.png&#34; alt=&#34;&#34; class=&#34;pure-img&#34; &gt;&lt;/center&gt;
&lt;/p&gt;

&lt;p&gt;Beside the interface we see the VRF name associated to the network that the interface belong to. On the same line we have some others informations, security group, floating-ips, VM id, etc.&lt;/p&gt;

&lt;p&gt;Clicking on the VRF link brings us to the index page of this VRF. We see that we have links to VRFs according to their type: Unicast, Multicast, Layer 2. By default, OpenContrail doesn’t handle the Layer 2. As said before most of the Layer 2 traffic from the virtual machines are trapped by the local vRouter which acts as an ARP responder. But some specific packets like broadcasts still need to be handled, that’s why there is a specific Layer 2 VRF.&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://safchain.github.io/images/a_journey_of_a_packet_within_opencontrail/image04.png&#34; alt=&#34;&#34; class=&#34;pure-img&#34; &gt;&lt;/center&gt;
&lt;/p&gt;

&lt;p&gt;Clicking on the link in the &lt;em&gt;ucindex&lt;/em&gt; (Unicast) column, we can see all the unicast L3 routes of our virtual network handled by this vRouter. Since &lt;em&gt;vm1&lt;/em&gt; should be able to reach &lt;em&gt;vm2&lt;/em&gt;, we should see a route with the IP of &lt;em&gt;vm2&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://safchain.github.io/images/a_journey_of_a_packet_within_opencontrail/image03.png&#34; alt=&#34;&#34; class=&#34;pure-img&#34; &gt;&lt;/center&gt;
&lt;/p&gt;

&lt;p&gt;Thanks to this interface we see that in order to reach the IP 192.168.0.3 which is the IP of our &lt;em&gt;vm2&lt;/em&gt;, the packet is going to be forwarded through a GRE tunnel whose endpoint is the IP of the compute node hosting &lt;em&gt;vm2&lt;/em&gt;. That’s what we see in the &lt;em&gt;“dip”&lt;/em&gt; (Destination IP) field. We see that the packet will be encapsulated in a MPLS packet. The MPLS label will be &lt;em&gt;16&lt;/em&gt;, as shown in the label column.&lt;/p&gt;

&lt;p&gt;Ok, so we saw at the agent level how the packet is going to be forwarded, but we may want to check on the datapath side. OpenContrail provides command line tools for that purpose.&lt;/p&gt;

&lt;p&gt;In the case of the agent for instance, we can see the interfaces handled by the vRouter kernel module and the associated VRF.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ vif --list
Vrouter Interface Table

Flags: P=Policy, X=Cross Connect, S=Service Chain, Mr=Receive Mirror
      Mt=Transmit Mirror, Tc=Transmit Checksum Offload, L3=Layer 3, L2=Layer 2
      D=DHCP, Vp=Vhost Physical, Pr=Promiscuous, Vnt=Native Vlan Tagged
      Mnp=No MAC Proxy, Dpdk=DPDK PMD Interface, Rfl=Receive Filtering Offload,
      Mon=Interface is Monitored, Uuf=Unknown Unicast Flood

vif0/0      OS: eth0
           Type:Physical HWaddr:fa:16:3e:68:f9:e8 IPaddr:0
           Vrf:0 Flags:TcL3L2Vp MTU:1514 Ref:5
           RX packets:1598309  bytes:315532297 errors:0
           TX packets:1407307  bytes:383580260 errors:0

vif0/1      OS: vhost0
           Type:Host HWaddr:fa:16:3e:68:f9:e8 IPaddr:a2b5b0a
           Vrf:0 Flags:L3L2 MTU:1514 Ref:3
           RX packets:1403461  bytes:383378275 errors:0
           TX packets:1595855  bytes:315456061 errors:0

vif0/2      OS: pkt0
           Type:Agent HWaddr:00:00:5e:00:01:00 IPaddr:0
           Vrf:65535 Flags:L3 MTU:1514 Ref:2
           RX packets:4389  bytes:400688 errors:0
           TX packets:6931  bytes:548756 errors:0

vif0/3      OS: tapa87ad91e-28
           Type:Virtual HWaddr:00:00:5e:00:01:00 IPaddr:0
           Vrf:1 Flags:PL3L2 MTU:9160 Ref:6
           RX packets:565  bytes:105481 errors:0
           TX packets:587  bytes:80083 errors:0

vif0/4350   OS: pkt3
           Type:Stats HWaddr:00:00:00:00:00:00 IPaddr:0
           Vrf:65535 Flags:L3L2 MTU:9136 Ref:1
           RX packets:3  bytes:294 errors:0
           TX packets:3  bytes:252 errors:0

vif0/4351   OS: pkt1
           Type:Stats HWaddr:00:00:00:00:00:00 IPaddr:0
           Vrf:65535 Flags:L3L2 MTU:9136 Ref:1
           RX packets:10  bytes:840 errors:0
           TX packets:10  bytes:840 errors:0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have our TAP interface at this index &lt;em&gt;3&lt;/em&gt; and the VRF associated which is the number &lt;em&gt;1&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Let’s now check the routes for this VRF. For that purpose we use the &lt;em&gt;rt&lt;/em&gt; command line.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ rt --dump 1
Vrouter inet4 routing table 0/1/unicast
Flags: L=Label Valid, P=Proxy ARP, T=Trap ARP, F=Flood ARP

Destination          PPL        Flags        Label         Nexthop    Stitched MAC(Index)

...
192.168.0.3/32         32           LP         16             19        -
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We see that the MPLS label used is &lt;em&gt;16&lt;/em&gt;. In order to know how the packet will be forwarded we have to check the NextHop used for this route.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ nh --get 19
Id:19         Type:Tunnel    Fmly: AF_INET  Flags:Valid, MPLSoGRE,   Rid:0  Ref_cnt:2 Vrf:0
             Oif:0 Len:14 Flags Valid, MPLSoGRE,  Data:fa 16 3e 4b f6 05 fa 16 3e 68 f9 e8 08 00
             Vrf:0  Sip:10.43.91.10  Dip:10.43.91.12
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have almost the same informations that the agent gave us. Here in the &lt;em&gt;Oif&lt;/em&gt; field, we have the interface where the packet will be sent to the other compute node. Thanks to the &lt;em&gt;vif&lt;/em&gt; command line we can get the details about this interface.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ vif --get 0
Vrouter Interface Table

Flags: P=Policy, X=Cross Connect, S=Service Chain, Mr=Receive Mirror
      Mt=Transmit Mirror, Tc=Transmit Checksum Offload, L3=Layer 3, L2=Layer 2
      D=DHCP, Vp=Vhost Physical, Pr=Promiscuous, Vnt=Native Vlan Tagged
      Mnp=No MAC Proxy, Dpdk=DPDK PMD Interface, Rfl=Receive Filtering Offload, Mon=Interface is Monitored
      Uuf=Unknown Unicast Flood

vif0/0      OS: eth0
           Type:Physical HWaddr:fa:16:3e:68:f9:e8 IPaddr:0
           Vrf:0 Flags:TcL3L2Vp MTU:1514 Ref:5
           RX packets:1602164  bytes:316196179 errors:0
           TX packets:1410642  bytes:384855228 errors:0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As the packet will go through the &lt;em&gt;eth0&lt;/em&gt; interface, a &lt;em&gt;tcpdump&lt;/em&gt; should confirm what we described above.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ sudo tcpdump -n -i eth0 dst 10.43.91.12
12:13:16.908957 IP 10.43.91.10 &amp;amp;gt; 10.43.91.12: GREv0,
length 92: MPLS (label 16, exp 0, [S], ttl 63)
IP 10.0.0.3 &amp;gt; 192.168.0.3: ICMP echo request, id 5889, seq 43, length 64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As the tunnel endpoint shows, the packet will be directly forwarded to the compute node that is hosting the destination VM, not using a third party routing device.&lt;/p&gt;

&lt;p&gt;On the other side, the vRouter on the second compute node will receive the encapsulated packet. According to the MPLS Label, it does a lookup on a MPLS Label/NextHop as we can see on its introspect.&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;img src=&#34;http://safchain.github.io/images/a_journey_of_a_packet_within_opencontrail/image05.png&#34; alt=&#34;&#34; class=&#34;pure-img&#34; &gt;&lt;/center&gt;
&lt;/p&gt;

&lt;p&gt;As we can see here the NextHop field for the Label &lt;em&gt;16&lt;/em&gt; is the TAP interface of our second VM. On the datapath side we can check the same informations. Checking the MPLS Label/NextHop table :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ mpls --get 16
MPLS Input Label Map

  Label    NextHop
-------------------
     16        14
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip;and finally the NextHop and the interface with the following commands :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ nh --get 14
Id:14         Type:Encap     Fmly: AF_INET  Flags:Valid, Policy,   Rid:0  Ref_cnt:4 Vrf:1
             EncapFmly:0806 Oif:3 Len:14 Data:02 8a 39 ff 98 d3 00 00 5e 00 01 00 08 00
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ vif --get 3
Vrouter Interface Table

Flags: P=Policy, X=Cross Connect, S=Service Chain, Mr=Receive Mirror
      Mt=Transmit Mirror, Tc=Transmit Checksum Offload, L3=Layer 3, L2=Layer 2
      D=DHCP, Vp=Vhost Physical, Pr=Promiscuous, Vnt=Native Vlan Tagged
      Mnp=No MAC Proxy, Dpdk=DPDK PMD Interface, Rfl=Receive Filtering Offload, Mon=Interface is Monitored
      Uuf=Unknown Unicast Flood

vif0/3      OS: tap8a39ff98-d3
           Type:Virtual HWaddr:00:00:5e:00:01:00 IPaddr:0
           Vrf:1 Flags:PL3L2 MTU:9160 Ref:6
           RX packets:2957  bytes:293636 errors:0
           TX packets:3085  bytes:297115 errors:0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This post was just an overview on how the packets are forwarded from one node to another and what are the interfaces/tools that you can use for troubleshooting purpose. One of the interesting thing with OpenContrail is that almost all the components have their own introspect interface helping you a lot during troubleshooting sessions. As we saw, the routing is fully distributed in OpenContrail, each vRouter handles a part of the routing using well known routing protocols like BGP/MPLS which proved their ability to scale.&lt;/p&gt;
</description>
        </item>
      
    

  </channel>
</rss>
